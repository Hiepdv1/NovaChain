// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: pending_transactions.sql

package dbPendingTx

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const countPendingTransactionsByAddr = `-- name: CountPendingTransactionsByAddr :one
SELECT COUNT(*) FROM pending_transactions
WHERE address = $1
`

func (q *Queries) CountPendingTransactionsByAddr(ctx context.Context, address string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPendingTransactionsByAddr, address)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPendingTxs = `-- name: CountPendingTxs :one
select COUNT(*) FROM pending_transactions
where status in ('mining', 'pending')
`

func (q *Queries) CountPendingTxs(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPendingTxs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTodayPendingTxs = `-- name: CountTodayPendingTxs :one
select COUNT(*) FROM pending_transactions
where created_at >= date_trunc('day', now())
and created_at < date_trunc('day', now()) + INTERVAL '1 day' AND status in ('mining', 'pending')
`

func (q *Queries) CountTodayPendingTxs(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTodayPendingTxs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const insertPendingTransaction = `-- name: InsertPendingTransaction :one
INSERT INTO pending_transactions (tx_id, address, receiver_address, status, priority, message, amount, fee)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, tx_id, address, receiver_address, status, amount, fee, priority, message, created_at, updated_at
`

type InsertPendingTransactionParams struct {
	TxID            string
	Address         string
	ReceiverAddress string
	Status          string
	Priority        sql.NullInt32
	Message         sql.NullString
	Amount          string
	Fee             string
}

func (q *Queries) InsertPendingTransaction(ctx context.Context, arg InsertPendingTransactionParams) (PendingTransaction, error) {
	row := q.db.QueryRowContext(ctx, insertPendingTransaction,
		arg.TxID,
		arg.Address,
		arg.ReceiverAddress,
		arg.Status,
		arg.Priority,
		arg.Message,
		arg.Amount,
		arg.Fee,
	)
	var i PendingTransaction
	err := row.Scan(
		&i.ID,
		&i.TxID,
		&i.Address,
		&i.ReceiverAddress,
		&i.Status,
		&i.Amount,
		&i.Fee,
		&i.Priority,
		&i.Message,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const pendingTxExists = `-- name: PendingTxExists :one
SELECT EXISTS (
    SELECT 1
    FROM pending_transactions
    WHERE tx_id = $1
      AND status = ANY($2::text[])
)
`

type PendingTxExistsParams struct {
	TxID   string
	Status []string
}

func (q *Queries) PendingTxExists(ctx context.Context, arg PendingTxExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, pendingTxExists, arg.TxID, pq.Array(arg.Status))
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const pendingTxsByAddress = `-- name: PendingTxsByAddress :many
SELECT p.id, p.tx_id, p.address, p.receiver_address, p.status, p.amount, p.fee, p.priority, p.message, p.created_at, p.updated_at, pd.raw_tx, pd.pub_key_hash
FROM pending_transactions p
JOIN pending_tx_data pd ON p.id = pd.tx_ref
WHERE p.address = $1
ORDER BY p.created_at DESC
LIMIT $2 OFFSET $3
`

type PendingTxsByAddressParams struct {
	Address string
	Limit   int32
	Offset  int32
}

type PendingTxsByAddressRow struct {
	ID              uuid.UUID
	TxID            string
	Address         string
	ReceiverAddress string
	Status          string
	Amount          string
	Fee             string
	Priority        sql.NullInt32
	Message         sql.NullString
	CreatedAt       sql.NullTime
	UpdatedAt       sql.NullTime
	RawTx           json.RawMessage
	PubKeyHash      string
}

func (q *Queries) PendingTxsByAddress(ctx context.Context, arg PendingTxsByAddressParams) ([]PendingTxsByAddressRow, error) {
	rows, err := q.db.QueryContext(ctx, pendingTxsByAddress, arg.Address, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PendingTxsByAddressRow
	for rows.Next() {
		var i PendingTxsByAddressRow
		if err := rows.Scan(
			&i.ID,
			&i.TxID,
			&i.Address,
			&i.ReceiverAddress,
			&i.Status,
			&i.Amount,
			&i.Fee,
			&i.Priority,
			&i.Message,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RawTx,
			&i.PubKeyHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pendingTxsByAddressAndStatus = `-- name: PendingTxsByAddressAndStatus :many
SELECT p.id, p.tx_id, p.address, p.receiver_address, p.status, p.amount, p.fee, p.priority, p.message, p.created_at, p.updated_at, pd.raw_tx, pd.pub_key_hash
FROM pending_transactions p
JOIN pending_tx_data pd ON p.id = pd.tx_ref
WHERE p.address = $1
  AND status = ANY($4::text[])
ORDER BY p.created_at DESC
LIMIT $2 OFFSET $3
`

type PendingTxsByAddressAndStatusParams struct {
	Address string
	Limit   int32
	Offset  int32
	Status  []string
}

type PendingTxsByAddressAndStatusRow struct {
	ID              uuid.UUID
	TxID            string
	Address         string
	ReceiverAddress string
	Status          string
	Amount          string
	Fee             string
	Priority        sql.NullInt32
	Message         sql.NullString
	CreatedAt       sql.NullTime
	UpdatedAt       sql.NullTime
	RawTx           json.RawMessage
	PubKeyHash      string
}

func (q *Queries) PendingTxsByAddressAndStatus(ctx context.Context, arg PendingTxsByAddressAndStatusParams) ([]PendingTxsByAddressAndStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, pendingTxsByAddressAndStatus,
		arg.Address,
		arg.Limit,
		arg.Offset,
		pq.Array(arg.Status),
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PendingTxsByAddressAndStatusRow
	for rows.Next() {
		var i PendingTxsByAddressAndStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.TxID,
			&i.Address,
			&i.ReceiverAddress,
			&i.Status,
			&i.Amount,
			&i.Fee,
			&i.Priority,
			&i.Message,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RawTx,
			&i.PubKeyHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectPendingTransactions = `-- name: SelectPendingTransactions :many
SELECT p.id, p.tx_id, p.address, p.receiver_address, p.status, p.amount, p.fee, p.priority, p.message, p.created_at, p.updated_at, pd.raw_tx, pd.pub_key_hash
FROM pending_transactions p
JOIN pending_tx_data pd ON p.id = pd.tx_ref
WHERE p.status = $1
ORDER BY p.fee DESC, p.created_at ASC
LIMIT $2 OFFSET $3
`

type SelectPendingTransactionsParams struct {
	Status string
	Limit  int32
	Offset int32
}

type SelectPendingTransactionsRow struct {
	ID              uuid.UUID
	TxID            string
	Address         string
	ReceiverAddress string
	Status          string
	Amount          string
	Fee             string
	Priority        sql.NullInt32
	Message         sql.NullString
	CreatedAt       sql.NullTime
	UpdatedAt       sql.NullTime
	RawTx           json.RawMessage
	PubKeyHash      string
}

func (q *Queries) SelectPendingTransactions(ctx context.Context, arg SelectPendingTransactionsParams) ([]SelectPendingTransactionsRow, error) {
	rows, err := q.db.QueryContext(ctx, selectPendingTransactions, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectPendingTransactionsRow
	for rows.Next() {
		var i SelectPendingTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.TxID,
			&i.Address,
			&i.ReceiverAddress,
			&i.Status,
			&i.Amount,
			&i.Fee,
			&i.Priority,
			&i.Message,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RawTx,
			&i.PubKeyHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectTxPendingByTxID = `-- name: SelectTxPendingByTxID :one
SELECT id, tx_id, address, receiver_address, status, amount, fee, priority, message, created_at, updated_at FROM pending_transactions
WHERE tx_id = $1 LIMIT 1
`

func (q *Queries) SelectTxPendingByTxID(ctx context.Context, txID string) (PendingTransaction, error) {
	row := q.db.QueryRowContext(ctx, selectTxPendingByTxID, txID)
	var i PendingTransaction
	err := row.Scan(
		&i.ID,
		&i.TxID,
		&i.Address,
		&i.ReceiverAddress,
		&i.Status,
		&i.Amount,
		&i.Fee,
		&i.Priority,
		&i.Message,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePendingTransactionPriority = `-- name: UpdatePendingTransactionPriority :one
UPDATE pending_transactions
SET priority = $2, updated_at = now()
WHERE tx_id = $1
RETURNING id, tx_id, address, receiver_address, status, amount, fee, priority, message, created_at, updated_at
`

type UpdatePendingTransactionPriorityParams struct {
	TxID     string
	Priority sql.NullInt32
}

func (q *Queries) UpdatePendingTransactionPriority(ctx context.Context, arg UpdatePendingTransactionPriorityParams) (PendingTransaction, error) {
	row := q.db.QueryRowContext(ctx, updatePendingTransactionPriority, arg.TxID, arg.Priority)
	var i PendingTransaction
	err := row.Scan(
		&i.ID,
		&i.TxID,
		&i.Address,
		&i.ReceiverAddress,
		&i.Status,
		&i.Amount,
		&i.Fee,
		&i.Priority,
		&i.Message,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePendingTransactionStatus = `-- name: UpdatePendingTransactionStatus :one
UPDATE pending_transactions
SET status = $2, updated_at = now()
WHERE tx_id = $1
RETURNING id, tx_id, address, receiver_address, status, amount, fee, priority, message, created_at, updated_at
`

type UpdatePendingTransactionStatusParams struct {
	TxID   string
	Status string
}

func (q *Queries) UpdatePendingTransactionStatus(ctx context.Context, arg UpdatePendingTransactionStatusParams) (PendingTransaction, error) {
	row := q.db.QueryRowContext(ctx, updatePendingTransactionStatus, arg.TxID, arg.Status)
	var i PendingTransaction
	err := row.Scan(
		&i.ID,
		&i.TxID,
		&i.Address,
		&i.ReceiverAddress,
		&i.Status,
		&i.Amount,
		&i.Fee,
		&i.Priority,
		&i.Message,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePendingTxsStatus = `-- name: UpdatePendingTxsStatus :execrows
UPDATE pending_transactions
SET status = $1,
    updated_at = NOW()
WHERE tx_id = ANY($2::text[])
  AND status = ANY($3::text[])
`

type UpdatePendingTxsStatusParams struct {
	NewStatus string
	TxIds     []string
	OldStatus []string
}

func (q *Queries) UpdatePendingTxsStatus(ctx context.Context, arg UpdatePendingTxsStatusParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updatePendingTxsStatus, arg.NewStatus, pq.Array(arg.TxIds), pq.Array(arg.OldStatus))
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
