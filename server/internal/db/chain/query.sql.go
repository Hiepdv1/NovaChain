// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package dbchain

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/google/uuid"
)

const countDistinctMiners = `-- name: CountDistinctMiners :one
SELECT COUNT(DISTINCT o.pub_key_hash) AS total_miners
FROM blocks b
JOIN transactions tx ON tx.b_id = b.b_id
JOIN tx_inputs i ON i.tx_id = tx.tx_id
JOIN tx_outputs o ON o.tx_id = tx.tx_id
WHERE i.out_index = -1
  AND b.height > 1
  AND o.pub_key_hash IS NOT NULL
`

func (q *Queries) CountDistinctMiners(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDistinctMiners)
	var total_miners int64
	err := row.Scan(&total_miners)
	return total_miners, err
}

const countFuzzy = `-- name: CountFuzzy :one
SELECT COUNT(*) AS total_count
FROM (
  SELECT 1
  FROM blocks b
  WHERE similarity(b.b_id::TEXT, $1) > 0.1
  
  UNION ALL
  
  SELECT 1
  FROM transactions t 
  JOIN tx_inputs i on i.tx_id = t.tx_id
  WHERE similarity(t.tx_id::text, $1) > 0.1 AND i.out_index > -1
) AS unified
`

func (q *Queries) CountFuzzy(ctx context.Context, searchquery string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countFuzzy, searchquery)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const countFuzzyByType = `-- name: CountFuzzyByType :many
SELECT type, COUNT(*)::BIGINT AS total
FROM (
  SELECT 'block' AS type
  FROM blocks
  WHERE blocks.b_id % $1

  UNION ALL

  SELECT 'transaction' AS type
  FROM transactions
  WHERE transactions.tx_id % $1 
     OR transactions.fromHash % $1 
     OR transactions.toHash % $1
) AS unified
GROUP BY type
`

type CountFuzzyByTypeRow struct {
	Type  string
	Total int64
}

func (q *Queries) CountFuzzyByType(ctx context.Context, bID string) ([]CountFuzzyByTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, countFuzzyByType, bID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountFuzzyByTypeRow
	for rows.Next() {
		var i CountFuzzyByTypeRow
		if err := rows.Scan(&i.Type, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countFuzzyTransactionsByBlock = `-- name: CountFuzzyTransactionsByBlock :one
SELECT COUNT(*) AS total_count
FROM transactions
WHERE 
  b_id = $1 AND
  similarity(tx_id::text, $2) > 0
`

type CountFuzzyTransactionsByBlockParams struct {
	BHash       string
	SearchQuery string
}

func (q *Queries) CountFuzzyTransactionsByBlock(ctx context.Context, arg CountFuzzyTransactionsByBlockParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countFuzzyTransactionsByBlock, arg.BHash, arg.SearchQuery)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const countMiners = `-- name: CountMiners :one
SELECT 
	COUNT(DISTINCT o.pub_key_hash)              
FROM blocks b
JOIN transactions tx ON tx.b_id = b.b_id
JOIN tx_inputs i ON i.tx_id = tx.tx_id
JOIN tx_outputs o ON o.tx_id = tx.tx_id
WHERE i.out_index = -1
  AND b.height > 1
`

func (q *Queries) CountMiners(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMiners)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRecentTransaction = `-- name: CountRecentTransaction :one
SELECT COUNT(*) FROM transactions
WHERE fromhash = $1::TEXT OR
tohash = $1::TEXT
`

func (q *Queries) CountRecentTransaction(ctx context.Context, pubKeyHash string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countRecentTransaction, pubKeyHash)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTodayTransactions = `-- name: CountTodayTransactions :one
select COUNT(*) from transactions
where create_at >= EXTRACT(EPOCH FROM date_trunc('day', now()))
and create_at < EXTRACT(EPOCH FROM date_trunc('day', now()) + INTERVAL '1 day')
and fromHash != '' and toHash != ''
`

func (q *Queries) CountTodayTransactions(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTodayTransactions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTransactionByBID = `-- name: CountTransactionByBID :one
select COUNT(*) from transactions where b_id = $1
`

func (q *Queries) CountTransactionByBID(ctx context.Context, bID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTransactionByBID, bID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBlock = `-- name: CreateBlock :one
insert into blocks (
    b_id, prev_hash, nonce, height,
    merkle_root, nbits, tx_count, nchain_work, size, timestamp
) values (
    $1, $2, $3, $4,
    $5, $6, $7, $8,
    $9, $10
) returning id, b_id, prev_hash, nonce, height, merkle_root, nbits, tx_count, nchain_work, size, timestamp
`

type CreateBlockParams struct {
	BID        string
	PrevHash   sql.NullString
	Nonce      int64
	Height     int64
	MerkleRoot string
	Nbits      int64
	TxCount    int64
	NchainWork string
	Size       float64
	Timestamp  int64
}

func (q *Queries) CreateBlock(ctx context.Context, arg CreateBlockParams) (Block, error) {
	row := q.db.QueryRowContext(ctx, createBlock,
		arg.BID,
		arg.PrevHash,
		arg.Nonce,
		arg.Height,
		arg.MerkleRoot,
		arg.Nbits,
		arg.TxCount,
		arg.NchainWork,
		arg.Size,
		arg.Timestamp,
	)
	var i Block
	err := row.Scan(
		&i.ID,
		&i.BID,
		&i.PrevHash,
		&i.Nonce,
		&i.Height,
		&i.MerkleRoot,
		&i.Nbits,
		&i.TxCount,
		&i.NchainWork,
		&i.Size,
		&i.Timestamp,
	)
	return i, err
}

const createTransaction = `-- name: CreateTransaction :one
insert into transactions (tx_id, b_id, fromHash, toHash, amount, fee, create_at)
values ($1, $2, $3, $4, $5, $6, $7) returning id, tx_id, b_id, create_at, amount, fee, fromhash, tohash
`

type CreateTransactionParams struct {
	TxID     string
	BID      string
	Fromhash sql.NullString
	Tohash   sql.NullString
	Amount   sql.NullString
	Fee      sql.NullString
	CreateAt int64
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, createTransaction,
		arg.TxID,
		arg.BID,
		arg.Fromhash,
		arg.Tohash,
		arg.Amount,
		arg.Fee,
		arg.CreateAt,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.TxID,
		&i.BID,
		&i.CreateAt,
		&i.Amount,
		&i.Fee,
		&i.Fromhash,
		&i.Tohash,
	)
	return i, err
}

const createTxInput = `-- name: CreateTxInput :one
insert into tx_inputs (tx_id, input_tx_id, out_index, sig, b_id, pub_key)
values ($1, $2, $3, $4, $5, $6) returning id, tx_id, input_tx_id, out_index, sig, b_id, pub_key
`

type CreateTxInputParams struct {
	TxID      string
	InputTxID sql.NullString
	OutIndex  int64
	Sig       sql.NullString
	BID       string
	PubKey    sql.NullString
}

func (q *Queries) CreateTxInput(ctx context.Context, arg CreateTxInputParams) (TxInput, error) {
	row := q.db.QueryRowContext(ctx, createTxInput,
		arg.TxID,
		arg.InputTxID,
		arg.OutIndex,
		arg.Sig,
		arg.BID,
		arg.PubKey,
	)
	var i TxInput
	err := row.Scan(
		&i.ID,
		&i.TxID,
		&i.InputTxID,
		&i.OutIndex,
		&i.Sig,
		&i.BID,
		&i.PubKey,
	)
	return i, err
}

const createTxOutput = `-- name: CreateTxOutput :one
insert into tx_outputs (tx_id, value, pub_key_hash, b_id, index)
values ($1, $2, $3, $4, $5) returning id, tx_id, index, value, b_id, pub_key_hash
`

type CreateTxOutputParams struct {
	TxID       string
	Value      string
	PubKeyHash string
	BID        string
	Index      int64
}

func (q *Queries) CreateTxOutput(ctx context.Context, arg CreateTxOutputParams) (TxOutput, error) {
	row := q.db.QueryRowContext(ctx, createTxOutput,
		arg.TxID,
		arg.Value,
		arg.PubKeyHash,
		arg.BID,
		arg.Index,
	)
	var i TxOutput
	err := row.Scan(
		&i.ID,
		&i.TxID,
		&i.Index,
		&i.Value,
		&i.BID,
		&i.PubKeyHash,
	)
	return i, err
}

const deleteBlockByBID = `-- name: DeleteBlockByBID :exec
delete from blocks
where b_id = $1
`

func (q *Queries) DeleteBlockByBID(ctx context.Context, bID string) error {
	_, err := q.db.ExecContext(ctx, deleteBlockByBID, bID)
	return err
}

const deleteBlockByHeight = `-- name: DeleteBlockByHeight :exec
DELETE FROM blocks
WHERE height = $1
`

func (q *Queries) DeleteBlockByHeight(ctx context.Context, height int64) error {
	_, err := q.db.ExecContext(ctx, deleteBlockByHeight, height)
	return err
}

const findListTxOutputByBlockID = `-- name: FindListTxOutputByBlockID :many
select id, tx_id, index, value, b_id, pub_key_hash from tx_outputs where b_id = $1
`

func (q *Queries) FindListTxOutputByBlockID(ctx context.Context, bID string) ([]TxOutput, error) {
	rows, err := q.db.QueryContext(ctx, findListTxOutputByBlockID, bID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TxOutput
	for rows.Next() {
		var i TxOutput
		if err := rows.Scan(
			&i.ID,
			&i.TxID,
			&i.Index,
			&i.Value,
			&i.BID,
			&i.PubKeyHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findTxInputByBlockID = `-- name: FindTxInputByBlockID :many
select id, tx_id, input_tx_id, out_index, sig, b_id, pub_key from tx_inputs where b_id = $1
`

func (q *Queries) FindTxInputByBlockID(ctx context.Context, bID string) ([]TxInput, error) {
	rows, err := q.db.QueryContext(ctx, findTxInputByBlockID, bID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TxInput
	for rows.Next() {
		var i TxInput
		if err := rows.Scan(
			&i.ID,
			&i.TxID,
			&i.InputTxID,
			&i.OutIndex,
			&i.Sig,
			&i.BID,
			&i.PubKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBestHeight = `-- name: GetBestHeight :one
select height from blocks order by height desc limit 1
`

func (q *Queries) GetBestHeight(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getBestHeight)
	var height int64
	err := row.Scan(&height)
	return height, err
}

const getBlockByBID = `-- name: GetBlockByBID :one
select id, b_id, prev_hash, nonce, height, merkle_root, nbits, tx_count, nchain_work, size, timestamp from blocks where b_id = $1 limit 1
`

func (q *Queries) GetBlockByBID(ctx context.Context, bID string) (Block, error) {
	row := q.db.QueryRowContext(ctx, getBlockByBID, bID)
	var i Block
	err := row.Scan(
		&i.ID,
		&i.BID,
		&i.PrevHash,
		&i.Nonce,
		&i.Height,
		&i.MerkleRoot,
		&i.Nbits,
		&i.TxCount,
		&i.NchainWork,
		&i.Size,
		&i.Timestamp,
	)
	return i, err
}

const getBlockByHeight = `-- name: GetBlockByHeight :one
select id, b_id, prev_hash, nonce, height, merkle_root, nbits, tx_count, nchain_work, size, timestamp from blocks where height = $1 limit 1
`

func (q *Queries) GetBlockByHeight(ctx context.Context, height int64) (Block, error) {
	row := q.db.QueryRowContext(ctx, getBlockByHeight, height)
	var i Block
	err := row.Scan(
		&i.ID,
		&i.BID,
		&i.PrevHash,
		&i.Nonce,
		&i.Height,
		&i.MerkleRoot,
		&i.Nbits,
		&i.TxCount,
		&i.NchainWork,
		&i.Size,
		&i.Timestamp,
	)
	return i, err
}

const getBlockCountByHours = `-- name: GetBlockCountByHours :one
SELECT COUNT(*) 
FROM blocks
WHERE timestamp >= EXTRACT(EPOCH FROM NOW())::bigint - ($1::bigint * 3600)
`

func (q *Queries) GetBlockCountByHours(ctx context.Context, hours int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getBlockCountByHours, hours)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getBlockDetailWithTransactions = `-- name: GetBlockDetailWithTransactions :one
SELECT 
  b.id, b.b_id, b.prev_hash, b.nonce, b.height, b.merkle_root, b.nbits, b.tx_count, b.nchain_work, b.size, b.timestamp,
  (
    SELECT jsonb_agg(tx_row)
    FROM (
      SELECT jsonb_build_object(
        'ID', tx.id,
        'BID', tx.b_id,
        'TxID', tx.tx_id,
        'Fromhash', tx.fromHash,
        'Tohash', tx.toHash,
        'Amount', tx.amount,
        'Fee', tx.fee,
        'CreateAt', tx.create_at
      ) AS tx_row
      FROM transactions tx
      WHERE tx.b_id = b.b_id
      ORDER BY tx.create_at DESC
      OFFSET $2
      LIMIT $3
    ) sub
  ) AS transactions,

  (
    SELECT COALESCE(SUM(tx.fee), 0)
    FROM transactions tx
    WHERE tx.b_id = b.b_id
  ) AS total_fee,

  (
    SELECT COALESCE(o.pub_key_hash, 'Unknown') 
    FROM tx_inputs i
    JOIN tx_outputs o 
      ON o.b_id = b.b_id 
     AND o.b_id = i.b_id
    WHERE i.out_index = -1
    LIMIT 1
  ) AS miner

FROM blocks b
WHERE b.b_id = $1
LIMIT 1
`

type GetBlockDetailWithTransactionsParams struct {
	BID      string
	OffsetTx int32
	LimitTx  int32
}

type GetBlockDetailWithTransactionsRow struct {
	ID           uuid.UUID
	BID          string
	PrevHash     sql.NullString
	Nonce        int64
	Height       int64
	MerkleRoot   string
	Nbits        int64
	TxCount      int64
	NchainWork   string
	Size         float64
	Timestamp    int64
	Transactions json.RawMessage
	TotalFee     interface{}
	Miner        string
}

func (q *Queries) GetBlockDetailWithTransactions(ctx context.Context, arg GetBlockDetailWithTransactionsParams) (GetBlockDetailWithTransactionsRow, error) {
	row := q.db.QueryRowContext(ctx, getBlockDetailWithTransactions, arg.BID, arg.OffsetTx, arg.LimitTx)
	var i GetBlockDetailWithTransactionsRow
	err := row.Scan(
		&i.ID,
		&i.BID,
		&i.PrevHash,
		&i.Nonce,
		&i.Height,
		&i.MerkleRoot,
		&i.Nbits,
		&i.TxCount,
		&i.NchainWork,
		&i.Size,
		&i.Timestamp,
		&i.Transactions,
		&i.TotalFee,
		&i.Miner,
	)
	return i, err
}

const getCountTodayWorkerMiners = `-- name: GetCountTodayWorkerMiners :one
SELECT COUNT(DISTINCT o.pub_key_hash) AS total_miners
FROM blocks b
JOIN transactions tx ON tx.b_id = b.b_id
JOIN tx_inputs i ON i.tx_id = tx.tx_id
JOIN tx_outputs o ON o.tx_id = tx.tx_id
WHERE i.out_index = -1
  AND b.height > 1
  AND o.pub_key_hash IS NOT NULL
  AND b.timestamp >= EXTRACT(EPOCH FROM date_trunc('day', now()))
  AND b.timestamp < EXTRACT(EPOCH FROM date_trunc('day', now()) + INTERVAL '1 day')
`

func (q *Queries) GetCountTodayWorkerMiners(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getCountTodayWorkerMiners)
	var total_miners int64
	err := row.Scan(&total_miners)
	return total_miners, err
}

const getCountTransaction = `-- name: GetCountTransaction :one
SELECT COUNT(*) FROM transactions
WHERE fromhash != '' AND tohash != ''
`

func (q *Queries) GetCountTransaction(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getCountTransaction)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getFullTransactionByBID = `-- name: GetFullTransactionByBID :many
select id, tx_id, b_id, create_at, amount, fee, fromhash, tohash FROM transactions where b_id = $1
`

func (q *Queries) GetFullTransactionByBID(ctx context.Context, bID string) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getFullTransactionByBID, bID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.TxID,
			&i.BID,
			&i.CreateAt,
			&i.Amount,
			&i.Fee,
			&i.Fromhash,
			&i.Tohash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastBlock = `-- name: GetLastBlock :one
select id, b_id, prev_hash, nonce, height, merkle_root, nbits, tx_count, nchain_work, size, timestamp from blocks order by height desc limit 1
`

func (q *Queries) GetLastBlock(ctx context.Context) (Block, error) {
	row := q.db.QueryRowContext(ctx, getLastBlock)
	var i Block
	err := row.Scan(
		&i.ID,
		&i.BID,
		&i.PrevHash,
		&i.Nonce,
		&i.Height,
		&i.MerkleRoot,
		&i.Nbits,
		&i.TxCount,
		&i.NchainWork,
		&i.Size,
		&i.Timestamp,
	)
	return i, err
}

const getListBlockByHours = `-- name: GetListBlockByHours :many
SELECT id, b_id, prev_hash, nonce, height, merkle_root, nbits, tx_count, nchain_work, size, timestamp FROM blocks 
WHERE timestamp >= EXTRACT(EPOCH FROM NOW())::bigint - ($1::bigint * 3600)
`

func (q *Queries) GetListBlockByHours(ctx context.Context, hours int64) ([]Block, error) {
	rows, err := q.db.QueryContext(ctx, getListBlockByHours, hours)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Block
	for rows.Next() {
		var i Block
		if err := rows.Scan(
			&i.ID,
			&i.BID,
			&i.PrevHash,
			&i.Nonce,
			&i.Height,
			&i.MerkleRoot,
			&i.Nbits,
			&i.TxCount,
			&i.NchainWork,
			&i.Size,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListBlocks = `-- name: GetListBlocks :many
SELECT
  b.id, b.b_id, b.prev_hash, b.nonce, b.height, b.merkle_root, b.nbits, b.tx_count, b.nchain_work, b.size, b.timestamp,
  miner.pub_key_hash, miner.value
FROM blocks b
LEFT JOIN LATERAL (
  SELECT o.pub_key_hash, o.value
  FROM tx_inputs i
  JOIN tx_outputs o ON i.tx_id = o.tx_id AND i.b_id = b.b_id
  WHERE i.out_index = -1
  LIMIT 1
) AS miner ON TRUE
ORDER BY b.height DESC
OFFSET $1 
LIMIT $2
`

type GetListBlocksParams struct {
	Offset int32
	Limit  int32
}

type GetListBlocksRow struct {
	ID         uuid.UUID
	BID        string
	PrevHash   sql.NullString
	Nonce      int64
	Height     int64
	MerkleRoot string
	Nbits      int64
	TxCount    int64
	NchainWork string
	Size       float64
	Timestamp  int64
	PubKeyHash string
	Value      string
}

func (q *Queries) GetListBlocks(ctx context.Context, arg GetListBlocksParams) ([]GetListBlocksRow, error) {
	rows, err := q.db.QueryContext(ctx, getListBlocks, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetListBlocksRow
	for rows.Next() {
		var i GetListBlocksRow
		if err := rows.Scan(
			&i.ID,
			&i.BID,
			&i.PrevHash,
			&i.Nonce,
			&i.Height,
			&i.MerkleRoot,
			&i.Nbits,
			&i.TxCount,
			&i.NchainWork,
			&i.Size,
			&i.Timestamp,
			&i.PubKeyHash,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListBlocksByHeight = `-- name: GetListBlocksByHeight :many
select id, b_id, prev_hash, nonce, height, merkle_root, nbits, tx_count, nchain_work, size, timestamp from blocks where height = $1
`

func (q *Queries) GetListBlocksByHeight(ctx context.Context, height int64) ([]Block, error) {
	rows, err := q.db.QueryContext(ctx, getListBlocksByHeight, height)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Block
	for rows.Next() {
		var i Block
		if err := rows.Scan(
			&i.ID,
			&i.BID,
			&i.PrevHash,
			&i.Nonce,
			&i.Height,
			&i.MerkleRoot,
			&i.Nbits,
			&i.TxCount,
			&i.NchainWork,
			&i.Size,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListFullTransaction = `-- name: GetListFullTransaction :many
SELECT tx.id, tx.tx_id, tx.b_id, tx.create_at, tx.amount, tx.fee, tx.fromhash, tx.tohash, i.id as inID, i.input_tx_id, i.out_index, i.sig, i.pub_key, o.index, o.value, o.pub_key_hash
FROM transactions tx
JOIN tx_inputs i on i.tx_id = tx.tx_id
JOIN tx_outputs o on o.tx_id = tx.tx_id
where i.out_index > -1
order by create_at desc
offset $1 limit $2
`

type GetListFullTransactionParams struct {
	Offset int32
	Limit  int32
}

type GetListFullTransactionRow struct {
	ID         uuid.UUID
	TxID       string
	BID        string
	CreateAt   int64
	Amount     sql.NullString
	Fee        sql.NullString
	Fromhash   sql.NullString
	Tohash     sql.NullString
	Inid       uuid.UUID
	InputTxID  sql.NullString
	OutIndex   int64
	Sig        sql.NullString
	PubKey     sql.NullString
	Index      int64
	Value      string
	PubKeyHash string
}

func (q *Queries) GetListFullTransaction(ctx context.Context, arg GetListFullTransactionParams) ([]GetListFullTransactionRow, error) {
	rows, err := q.db.QueryContext(ctx, getListFullTransaction, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetListFullTransactionRow
	for rows.Next() {
		var i GetListFullTransactionRow
		if err := rows.Scan(
			&i.ID,
			&i.TxID,
			&i.BID,
			&i.CreateAt,
			&i.Amount,
			&i.Fee,
			&i.Fromhash,
			&i.Tohash,
			&i.Inid,
			&i.InputTxID,
			&i.OutIndex,
			&i.Sig,
			&i.PubKey,
			&i.Index,
			&i.Value,
			&i.PubKeyHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListTransactionByBID = `-- name: GetListTransactionByBID :many
select id, tx_id, b_id, create_at, amount, fee, fromhash, tohash from transactions 
where b_id = $1
OFFSET $2
LIMIT $3
`

type GetListTransactionByBIDParams struct {
	BID    string
	Offset int32
	Limit  int32
}

func (q *Queries) GetListTransactionByBID(ctx context.Context, arg GetListTransactionByBIDParams) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getListTransactionByBID, arg.BID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.TxID,
			&i.BID,
			&i.CreateAt,
			&i.Amount,
			&i.Fee,
			&i.Fromhash,
			&i.Tohash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListTransactions = `-- name: GetListTransactions :many
select id, tx_id, b_id, create_at, amount, fee, fromhash, tohash from transactions
WHERE fromhash != '' AND tohash != ''
order by create_at desc offset $1 limit $2
`

type GetListTransactionsParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) GetListTransactions(ctx context.Context, arg GetListTransactionsParams) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getListTransactions, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.TxID,
			&i.BID,
			&i.CreateAt,
			&i.Amount,
			&i.Fee,
			&i.Fromhash,
			&i.Tohash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListTxInputByTxID = `-- name: GetListTxInputByTxID :many
select id, tx_id, input_tx_id, out_index, sig, b_id, pub_key from tx_inputs where tx_id = $1
`

func (q *Queries) GetListTxInputByTxID(ctx context.Context, txID string) ([]TxInput, error) {
	rows, err := q.db.QueryContext(ctx, getListTxInputByTxID, txID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TxInput
	for rows.Next() {
		var i TxInput
		if err := rows.Scan(
			&i.ID,
			&i.TxID,
			&i.InputTxID,
			&i.OutIndex,
			&i.Sig,
			&i.BID,
			&i.PubKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListTxOutputByTxId = `-- name: GetListTxOutputByTxId :many
select id, tx_id, index, value, b_id, pub_key_hash from tx_outputs where tx_id = $1
`

func (q *Queries) GetListTxOutputByTxId(ctx context.Context, txID string) ([]TxOutput, error) {
	rows, err := q.db.QueryContext(ctx, getListTxOutputByTxId, txID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TxOutput
	for rows.Next() {
		var i TxOutput
		if err := rows.Scan(
			&i.ID,
			&i.TxID,
			&i.Index,
			&i.Value,
			&i.BID,
			&i.PubKeyHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMiners = `-- name: GetMiners :many
WITH miner_stats AS (
	SELECT 
		o.pub_key_hash AS miner_pubkey,                 
		MIN(b.timestamp) AS first_mined_at,             
	  	MAX(b.timestamp) AS last_mined_at,              
		COUNT(DISTINCT b.b_id) AS mined_blocks          
	FROM blocks b
	JOIN transactions tx ON tx.b_id = b.b_id
	JOIN tx_inputs i ON i.tx_id = tx.tx_id
	JOIN tx_outputs o ON o.tx_id = tx.tx_id
	WHERE i.out_index = -1
	  AND b.height > 1
	GROUP BY o.pub_key_hash
)
SELECT 
	miner_pubkey,                                         
	mined_blocks,                                         
	first_mined_at,                                       
	last_mined_at,                                        
	SUM(mined_blocks) OVER () AS total_blocks_network,    
	ROUND(
	    mined_blocks * 100.0 / SUM(mined_blocks) OVER (),
	    2
  	) AS network_share_percent                            
FROM miner_stats
ORDER BY mined_blocks DESC
OFFSET $1
LIMIT $2
`

type GetMinersParams struct {
	Offset int32
	Limit  int32
}

type GetMinersRow struct {
	MinerPubkey         string
	MinedBlocks         int64
	FirstMinedAt        interface{}
	LastMinedAt         interface{}
	TotalBlocksNetwork  int64
	NetworkSharePercent string
}

func (q *Queries) GetMiners(ctx context.Context, arg GetMinersParams) ([]GetMinersRow, error) {
	rows, err := q.db.QueryContext(ctx, getMiners, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMinersRow
	for rows.Next() {
		var i GetMinersRow
		if err := rows.Scan(
			&i.MinerPubkey,
			&i.MinedBlocks,
			&i.FirstMinedAt,
			&i.LastMinedAt,
			&i.TotalBlocksNetwork,
			&i.NetworkSharePercent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentBlocksForNetworkInfo = `-- name: GetRecentBlocksForNetworkInfo :many
SELECT height, nbits, timestamp
FROM blocks
ORDER BY height DESC
LIMIT $1
`

type GetRecentBlocksForNetworkInfoRow struct {
	Height    int64
	Nbits     int64
	Timestamp int64
}

func (q *Queries) GetRecentBlocksForNetworkInfo(ctx context.Context, limit int32) ([]GetRecentBlocksForNetworkInfoRow, error) {
	rows, err := q.db.QueryContext(ctx, getRecentBlocksForNetworkInfo, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentBlocksForNetworkInfoRow
	for rows.Next() {
		var i GetRecentBlocksForNetworkInfoRow
		if err := rows.Scan(&i.Height, &i.Nbits, &i.Timestamp); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentTransaction = `-- name: GetRecentTransaction :many
WITH recent AS (
  SELECT 
    'sent'     AS type,
    tx.id,
    tx.tx_id,
    tx.b_id,
    tx.create_at,
    tx.amount,
    tx.fee,
    tx.fromhash,
    tx.tohash
  FROM transactions tx
  WHERE tx.fromhash = $3::TEXT

  UNION ALL

  SELECT 
    'received' AS type,
    tx.id,
    tx.tx_id,
    tx.b_id,
    tx.create_at,
    tx.amount,
    tx.fee,
    tx.fromhash,
    tx.tohash  
  FROM transactions tx
  WHERE tx.tohash = $3::TEXT
)
SELECT type, id, tx_id, b_id, create_at, amount, fee, fromhash, tohash
FROM recent
ORDER BY create_at DESC
OFFSET $1
LIMIT $2
`

type GetRecentTransactionParams struct {
	Offset     int32
	Limit      int32
	PubKeyHash string
}

type GetRecentTransactionRow struct {
	Type     string
	ID       uuid.UUID
	TxID     string
	BID      string
	CreateAt int64
	Amount   sql.NullString
	Fee      sql.NullString
	Fromhash sql.NullString
	Tohash   sql.NullString
}

func (q *Queries) GetRecentTransaction(ctx context.Context, arg GetRecentTransactionParams) ([]GetRecentTransactionRow, error) {
	rows, err := q.db.QueryContext(ctx, getRecentTransaction, arg.Offset, arg.Limit, arg.PubKeyHash)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentTransactionRow
	for rows.Next() {
		var i GetRecentTransactionRow
		if err := rows.Scan(
			&i.Type,
			&i.ID,
			&i.TxID,
			&i.BID,
			&i.CreateAt,
			&i.Amount,
			&i.Fee,
			&i.Fromhash,
			&i.Tohash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionByTxID = `-- name: GetTransactionByTxID :one
select id, tx_id, b_id, create_at, amount, fee, fromhash, tohash from transactions where tx_id = $1 limit 1
`

func (q *Queries) GetTransactionByTxID(ctx context.Context, txID string) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, getTransactionByTxID, txID)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.TxID,
		&i.BID,
		&i.CreateAt,
		&i.Amount,
		&i.Fee,
		&i.Fromhash,
		&i.Tohash,
	)
	return i, err
}

const getTxInputByTxID = `-- name: GetTxInputByTxID :one
select id, tx_id, input_tx_id, out_index, sig, b_id, pub_key from tx_inputs where tx_id = $1 limit 1
`

func (q *Queries) GetTxInputByTxID(ctx context.Context, txID string) (TxInput, error) {
	row := q.db.QueryRowContext(ctx, getTxInputByTxID, txID)
	var i TxInput
	err := row.Scan(
		&i.ID,
		&i.TxID,
		&i.InputTxID,
		&i.OutIndex,
		&i.Sig,
		&i.BID,
		&i.PubKey,
	)
	return i, err
}

const getTxOutputByTxID = `-- name: GetTxOutputByTxID :one
select id, tx_id, index, value, b_id, pub_key_hash from tx_outputs where tx_id = $1 limit 1
`

func (q *Queries) GetTxOutputByTxID(ctx context.Context, txID string) (TxOutput, error) {
	row := q.db.QueryRowContext(ctx, getTxOutputByTxID, txID)
	var i TxOutput
	err := row.Scan(
		&i.ID,
		&i.TxID,
		&i.Index,
		&i.Value,
		&i.BID,
		&i.PubKeyHash,
	)
	return i, err
}

const getTxOutputByTxIDAndIndex = `-- name: GetTxOutputByTxIDAndIndex :one
select id, tx_id, index, value, b_id, pub_key_hash from tx_outputs where tx_id = $1 and index = $2 limit 1
`

type GetTxOutputByTxIDAndIndexParams struct {
	TxID  string
	Index int64
}

func (q *Queries) GetTxOutputByTxIDAndIndex(ctx context.Context, arg GetTxOutputByTxIDAndIndexParams) (TxOutput, error) {
	row := q.db.QueryRowContext(ctx, getTxOutputByTxIDAndIndex, arg.TxID, arg.Index)
	var i TxOutput
	err := row.Scan(
		&i.ID,
		&i.TxID,
		&i.Index,
		&i.Value,
		&i.BID,
		&i.PubKeyHash,
	)
	return i, err
}

const getTxSummaryByPubKeyHash = `-- name: GetTxSummaryByPubKeyHash :one
WITH all_activity AS (
    SELECT 
        fromhash     AS pub_key_hash,
        COUNT(*)     AS total_tx_sent,
        SUM(amount::numeric)  AS total_sent,
        0::numeric            AS total_received
    FROM transactions
    WHERE fromhash = $1::TEXT
    GROUP BY fromhash

    UNION ALL

    SELECT 
        tohash       AS pub_key_hash,
        0                 AS total_tx_sent,
        0::numeric        AS total_sent,
        SUM(amount::numeric) AS total_received
    FROM transactions
    WHERE tohash = $1::TEXT
    GROUP BY tohash
),
aggregated AS (
    SELECT
        pub_key_hash,
        SUM(total_tx_sent)     AS total_tx,
        SUM(total_sent)        AS total_sent,
        SUM(total_received)    AS total_received
    FROM all_activity
    GROUP BY pub_key_hash
)
SELECT 
    pub_key_hash,
    COALESCE(total_tx, 0)             AS total_tx,
    COALESCE(total_sent, 0)::TEXT   AS total_sent,
    COALESCE(total_received, 0)::TEXT AS total_received
FROM aggregated
`

type GetTxSummaryByPubKeyHashRow struct {
	PubKeyHash    sql.NullString
	TotalTx       int64
	TotalSent     string
	TotalReceived string
}

func (q *Queries) GetTxSummaryByPubKeyHash(ctx context.Context, pubKeyHash string) (GetTxSummaryByPubKeyHashRow, error) {
	row := q.db.QueryRowContext(ctx, getTxSummaryByPubKeyHash, pubKeyHash)
	var i GetTxSummaryByPubKeyHashRow
	err := row.Scan(
		&i.PubKeyHash,
		&i.TotalTx,
		&i.TotalSent,
		&i.TotalReceived,
	)
	return i, err
}

const isExistingBlock = `-- name: IsExistingBlock :one
select exists (
    select 1 from blocks where b_id = $1
)
`

func (q *Queries) IsExistingBlock(ctx context.Context, bID string) (bool, error) {
	row := q.db.QueryRowContext(ctx, isExistingBlock, bID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const searchExact = `-- name: SearchExact :many
SELECT type, keyword, value
FROM (
  SELECT 
    'block' AS type, 
    blocks.b_id AS keyword, 
    blocks.height AS value
  FROM blocks
  WHERE blocks.b_id = $1

  UNION ALL

  SELECT 
    'transaction' AS type, 
    transactions.tx_id AS keyword, 
    transactions.amount AS value
  FROM transactions
  WHERE transactions.tx_id = $1 
     OR transactions.fromHash = $1 
     OR transactions.toHash = $1

  UNION ALL

  SELECT 
    'reward' AS type, 
    tx_outputs.pub_key_hash AS keyword, 
    tx_outputs.value AS value
  FROM tx_outputs
  WHERE tx_outputs.pub_key_hash = $1
) AS unified
`

type SearchExactRow struct {
	Type    string
	Keyword string
	Value   int64
}

func (q *Queries) SearchExact(ctx context.Context, bID string) ([]SearchExactRow, error) {
	rows, err := q.db.QueryContext(ctx, searchExact, bID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchExactRow
	for rows.Next() {
		var i SearchExactRow
		if err := rows.Scan(&i.Type, &i.Keyword, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchFuzzy = `-- name: SearchFuzzy :many
SELECT 
  type::TEXT,
  keyword::TEXT,
  data::JSONB
FROM (
  SELECT 
    'block' AS type,
    b.b_id AS keyword,
    jsonb_build_object(
        'height', b.height,
        'timestamp', b.timestamp,
        'size', b.size,
        'tx_count', b.tx_count,
        'miner', COALESCE(coinbase.pub_key_hash, 'unknown')
    ) AS data,
    similarity(b.b_id::text, $3) AS score
  FROM blocks b
  LEFT JOIN LATERAL (
    SELECT o.pub_key_hash
    FROM tx_inputs i
    JOIN tx_outputs o ON o.b_id = i.b_id AND o.b_id = b.b_id
    WHERE i.out_index = -1 AND i.b_id = b.b_id
    LIMIT 1
  ) coinbase ON true
  WHERE similarity(b.b_id::text, $3) > 0.1

  UNION ALL

  SELECT 
    'transaction' AS type,
    t.tx_id AS keyword,
    jsonb_build_object(
        'from', t.fromHash,
        'to', t.toHash,
        'amount', t.amount,
        'fee', t.fee,
        'timestamp', t.create_at
    ) AS data,
    similarity(t.tx_id::text, $3) AS score  
  FROM transactions t
  JOIN tx_inputs i on i.tx_id = t.tx_id
  WHERE similarity(t.tx_id::text, $3) > 0.1 AND i.out_index > -1
) AS unified
ORDER BY score DESC
OFFSET $1
LIMIT $2
`

type SearchFuzzyParams struct {
	Offset      int32
	Limit       int32
	SearchQuery string
}

type SearchFuzzyRow struct {
	Type    string
	Keyword string
	Data    json.RawMessage
}

func (q *Queries) SearchFuzzy(ctx context.Context, arg SearchFuzzyParams) ([]SearchFuzzyRow, error) {
	rows, err := q.db.QueryContext(ctx, searchFuzzy, arg.Offset, arg.Limit, arg.SearchQuery)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchFuzzyRow
	for rows.Next() {
		var i SearchFuzzyRow
		if err := rows.Scan(&i.Type, &i.Keyword, &i.Data); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchFuzzyTransactionsByBlock = `-- name: SearchFuzzyTransactionsByBlock :many
SELECT 
  id, tx_id, b_id, create_at, amount, fee, fromhash, tohash
FROM transactions
WHERE 
  b_id = $3 AND
  similarity(tx_id::text, $4) > 0
ORDER BY 
  similarity(tx_id::text, $4) DESC
OFFSET $1
LIMIT $2
`

type SearchFuzzyTransactionsByBlockParams struct {
	Offset      int32
	Limit       int32
	BHash       string
	SearchQuery string
}

func (q *Queries) SearchFuzzyTransactionsByBlock(ctx context.Context, arg SearchFuzzyTransactionsByBlockParams) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, searchFuzzyTransactionsByBlock,
		arg.Offset,
		arg.Limit,
		arg.BHash,
		arg.SearchQuery,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.TxID,
			&i.BID,
			&i.CreateAt,
			&i.Amount,
			&i.Fee,
			&i.Fromhash,
			&i.Tohash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
