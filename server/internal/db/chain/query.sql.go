// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package dbchain

import (
	"context"
	"database/sql"
)

const createBlock = `-- name: CreateBlock :one
insert into blocks (
    b_id, prev_hash, nonce, height,
    merkle_root, difficulty, tx_count, nchain_work, timestamp
) values (
    $1, $2, $3, $4,
    $5, $6, $7, $8,
    $9
) returning id, b_id, prev_hash, nonce, height, merkle_root, difficulty, tx_count, nchain_work, timestamp
`

type CreateBlockParams struct {
	BID        string
	PrevHash   sql.NullString
	Nonce      int64
	Height     int64
	MerkleRoot string
	Difficulty int64
	TxCount    int64
	NchainWork string
	Timestamp  int64
}

func (q *Queries) CreateBlock(ctx context.Context, arg CreateBlockParams) (Block, error) {
	row := q.db.QueryRowContext(ctx, createBlock,
		arg.BID,
		arg.PrevHash,
		arg.Nonce,
		arg.Height,
		arg.MerkleRoot,
		arg.Difficulty,
		arg.TxCount,
		arg.NchainWork,
		arg.Timestamp,
	)
	var i Block
	err := row.Scan(
		&i.ID,
		&i.BID,
		&i.PrevHash,
		&i.Nonce,
		&i.Height,
		&i.MerkleRoot,
		&i.Difficulty,
		&i.TxCount,
		&i.NchainWork,
		&i.Timestamp,
	)
	return i, err
}

const createTransaction = `-- name: CreateTransaction :one
insert into transactions (tx_id, b_id)
values ($1, $2) returning id, tx_id, b_id, create_at
`

type CreateTransactionParams struct {
	TxID string
	BID  string
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, createTransaction, arg.TxID, arg.BID)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.TxID,
		&i.BID,
		&i.CreateAt,
	)
	return i, err
}

const createTxInput = `-- name: CreateTxInput :one
insert into tx_inputs (tx_id, input_tx_id, out_index, sig, b_id, pub_key)
values ($1, $2, $3, $4, $5, $6) returning id, tx_id, input_tx_id, out_index, sig, b_id, pub_key
`

type CreateTxInputParams struct {
	TxID      string
	InputTxID sql.NullString
	OutIndex  int64
	Sig       sql.NullString
	BID       string
	PubKey    sql.NullString
}

func (q *Queries) CreateTxInput(ctx context.Context, arg CreateTxInputParams) (TxInput, error) {
	row := q.db.QueryRowContext(ctx, createTxInput,
		arg.TxID,
		arg.InputTxID,
		arg.OutIndex,
		arg.Sig,
		arg.BID,
		arg.PubKey,
	)
	var i TxInput
	err := row.Scan(
		&i.ID,
		&i.TxID,
		&i.InputTxID,
		&i.OutIndex,
		&i.Sig,
		&i.BID,
		&i.PubKey,
	)
	return i, err
}

const createTxOutput = `-- name: CreateTxOutput :one
insert into tx_outputs (tx_id, value, pub_key_hash, b_id, index)
values ($1, $2, $3, $4, $5) returning id, tx_id, index, value, b_id, pub_key_hash
`

type CreateTxOutputParams struct {
	TxID       string
	Value      string
	PubKeyHash string
	BID        string
	Index      int64
}

func (q *Queries) CreateTxOutput(ctx context.Context, arg CreateTxOutputParams) (TxOutput, error) {
	row := q.db.QueryRowContext(ctx, createTxOutput,
		arg.TxID,
		arg.Value,
		arg.PubKeyHash,
		arg.BID,
		arg.Index,
	)
	var i TxOutput
	err := row.Scan(
		&i.ID,
		&i.TxID,
		&i.Index,
		&i.Value,
		&i.BID,
		&i.PubKeyHash,
	)
	return i, err
}

const deleteBlockByBID = `-- name: DeleteBlockByBID :exec
delete from blocks
where b_id = $1
`

func (q *Queries) DeleteBlockByBID(ctx context.Context, bID string) error {
	_, err := q.db.ExecContext(ctx, deleteBlockByBID, bID)
	return err
}

const findListTxOutputByBlockID = `-- name: FindListTxOutputByBlockID :many
select id, tx_id, index, value, b_id, pub_key_hash from tx_outputs where b_id = $1
`

func (q *Queries) FindListTxOutputByBlockID(ctx context.Context, bID string) ([]TxOutput, error) {
	rows, err := q.db.QueryContext(ctx, findListTxOutputByBlockID, bID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TxOutput
	for rows.Next() {
		var i TxOutput
		if err := rows.Scan(
			&i.ID,
			&i.TxID,
			&i.Index,
			&i.Value,
			&i.BID,
			&i.PubKeyHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findTxInputByBlockID = `-- name: FindTxInputByBlockID :many
select id, tx_id, input_tx_id, out_index, sig, b_id, pub_key from tx_inputs where b_id = $1
`

func (q *Queries) FindTxInputByBlockID(ctx context.Context, bID string) ([]TxInput, error) {
	rows, err := q.db.QueryContext(ctx, findTxInputByBlockID, bID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TxInput
	for rows.Next() {
		var i TxInput
		if err := rows.Scan(
			&i.ID,
			&i.TxID,
			&i.InputTxID,
			&i.OutIndex,
			&i.Sig,
			&i.BID,
			&i.PubKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlockByBID = `-- name: GetBlockByBID :one
select id, b_id, prev_hash, nonce, height, merkle_root, difficulty, tx_count, nchain_work, timestamp from blocks where b_id = $1 limit 1
`

func (q *Queries) GetBlockByBID(ctx context.Context, bID string) (Block, error) {
	row := q.db.QueryRowContext(ctx, getBlockByBID, bID)
	var i Block
	err := row.Scan(
		&i.ID,
		&i.BID,
		&i.PrevHash,
		&i.Nonce,
		&i.Height,
		&i.MerkleRoot,
		&i.Difficulty,
		&i.TxCount,
		&i.NchainWork,
		&i.Timestamp,
	)
	return i, err
}

const getBlockByHeight = `-- name: GetBlockByHeight :one
select id, b_id, prev_hash, nonce, height, merkle_root, difficulty, tx_count, nchain_work, timestamp from blocks where height = $1 limit 1
`

func (q *Queries) GetBlockByHeight(ctx context.Context, height int64) (Block, error) {
	row := q.db.QueryRowContext(ctx, getBlockByHeight, height)
	var i Block
	err := row.Scan(
		&i.ID,
		&i.BID,
		&i.PrevHash,
		&i.Nonce,
		&i.Height,
		&i.MerkleRoot,
		&i.Difficulty,
		&i.TxCount,
		&i.NchainWork,
		&i.Timestamp,
	)
	return i, err
}

const getCountTransaction = `-- name: GetCountTransaction :one
SELECT COUNT(*) FROM transactions
`

func (q *Queries) GetCountTransaction(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getCountTransaction)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getLastBlock = `-- name: GetLastBlock :one
select id, b_id, prev_hash, nonce, height, merkle_root, difficulty, tx_count, nchain_work, timestamp from blocks order by height desc limit 1
`

func (q *Queries) GetLastBlock(ctx context.Context) (Block, error) {
	row := q.db.QueryRowContext(ctx, getLastBlock)
	var i Block
	err := row.Scan(
		&i.ID,
		&i.BID,
		&i.PrevHash,
		&i.Nonce,
		&i.Height,
		&i.MerkleRoot,
		&i.Difficulty,
		&i.TxCount,
		&i.NchainWork,
		&i.Timestamp,
	)
	return i, err
}

const getListBlocks = `-- name: GetListBlocks :many
select id, b_id, prev_hash, nonce, height, merkle_root, difficulty, tx_count, nchain_work, timestamp from blocks order by height desc offset $1 limit $2
`

type GetListBlocksParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) GetListBlocks(ctx context.Context, arg GetListBlocksParams) ([]Block, error) {
	rows, err := q.db.QueryContext(ctx, getListBlocks, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Block
	for rows.Next() {
		var i Block
		if err := rows.Scan(
			&i.ID,
			&i.BID,
			&i.PrevHash,
			&i.Nonce,
			&i.Height,
			&i.MerkleRoot,
			&i.Difficulty,
			&i.TxCount,
			&i.NchainWork,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListBlocksByHeight = `-- name: GetListBlocksByHeight :many
select id, b_id, prev_hash, nonce, height, merkle_root, difficulty, tx_count, nchain_work, timestamp from blocks where height = $1
`

func (q *Queries) GetListBlocksByHeight(ctx context.Context, height int64) ([]Block, error) {
	rows, err := q.db.QueryContext(ctx, getListBlocksByHeight, height)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Block
	for rows.Next() {
		var i Block
		if err := rows.Scan(
			&i.ID,
			&i.BID,
			&i.PrevHash,
			&i.Nonce,
			&i.Height,
			&i.MerkleRoot,
			&i.Difficulty,
			&i.TxCount,
			&i.NchainWork,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListTransactionByBID = `-- name: GetListTransactionByBID :many
select id, tx_id, b_id, create_at from transactions where b_id = $1
`

func (q *Queries) GetListTransactionByBID(ctx context.Context, bID string) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getListTransactionByBID, bID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.TxID,
			&i.BID,
			&i.CreateAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListTransactions = `-- name: GetListTransactions :many
select id, tx_id, b_id, create_at from transactions offset $1 limit $2
`

type GetListTransactionsParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) GetListTransactions(ctx context.Context, arg GetListTransactionsParams) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getListTransactions, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.TxID,
			&i.BID,
			&i.CreateAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListTxInputByTxID = `-- name: GetListTxInputByTxID :many
select id, tx_id, input_tx_id, out_index, sig, b_id, pub_key from tx_inputs where tx_id = $1
`

func (q *Queries) GetListTxInputByTxID(ctx context.Context, txID string) ([]TxInput, error) {
	rows, err := q.db.QueryContext(ctx, getListTxInputByTxID, txID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TxInput
	for rows.Next() {
		var i TxInput
		if err := rows.Scan(
			&i.ID,
			&i.TxID,
			&i.InputTxID,
			&i.OutIndex,
			&i.Sig,
			&i.BID,
			&i.PubKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListTxOutputByTxId = `-- name: GetListTxOutputByTxId :many
select id, tx_id, index, value, b_id, pub_key_hash from tx_outputs where tx_id = $1
`

func (q *Queries) GetListTxOutputByTxId(ctx context.Context, txID string) ([]TxOutput, error) {
	rows, err := q.db.QueryContext(ctx, getListTxOutputByTxId, txID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TxOutput
	for rows.Next() {
		var i TxOutput
		if err := rows.Scan(
			&i.ID,
			&i.TxID,
			&i.Index,
			&i.Value,
			&i.BID,
			&i.PubKeyHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionByTxID = `-- name: GetTransactionByTxID :one
select id, tx_id, b_id, create_at from transactions where tx_id = $1 limit 1
`

func (q *Queries) GetTransactionByTxID(ctx context.Context, txID string) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, getTransactionByTxID, txID)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.TxID,
		&i.BID,
		&i.CreateAt,
	)
	return i, err
}

const getTxInputByTxID = `-- name: GetTxInputByTxID :one
select id, tx_id, input_tx_id, out_index, sig, b_id, pub_key from tx_inputs where tx_id = $1 limit 1
`

func (q *Queries) GetTxInputByTxID(ctx context.Context, txID string) (TxInput, error) {
	row := q.db.QueryRowContext(ctx, getTxInputByTxID, txID)
	var i TxInput
	err := row.Scan(
		&i.ID,
		&i.TxID,
		&i.InputTxID,
		&i.OutIndex,
		&i.Sig,
		&i.BID,
		&i.PubKey,
	)
	return i, err
}

const getTxOutputByTxID = `-- name: GetTxOutputByTxID :one
select id, tx_id, index, value, b_id, pub_key_hash from tx_outputs where tx_id = $1 limit 1
`

func (q *Queries) GetTxOutputByTxID(ctx context.Context, txID string) (TxOutput, error) {
	row := q.db.QueryRowContext(ctx, getTxOutputByTxID, txID)
	var i TxOutput
	err := row.Scan(
		&i.ID,
		&i.TxID,
		&i.Index,
		&i.Value,
		&i.BID,
		&i.PubKeyHash,
	)
	return i, err
}

const getTxOutputByTxIDAndIndex = `-- name: GetTxOutputByTxIDAndIndex :one
select id, tx_id, index, value, b_id, pub_key_hash from tx_outputs where tx_id = $1 and index = $2 limit 1
`

type GetTxOutputByTxIDAndIndexParams struct {
	TxID  string
	Index int64
}

func (q *Queries) GetTxOutputByTxIDAndIndex(ctx context.Context, arg GetTxOutputByTxIDAndIndexParams) (TxOutput, error) {
	row := q.db.QueryRowContext(ctx, getTxOutputByTxIDAndIndex, arg.TxID, arg.Index)
	var i TxOutput
	err := row.Scan(
		&i.ID,
		&i.TxID,
		&i.Index,
		&i.Value,
		&i.BID,
		&i.PubKeyHash,
	)
	return i, err
}

const isExistingBlock = `-- name: IsExistingBlock :one
select exists (
    select 1 from blocks where b_id = $1
)
`

func (q *Queries) IsExistingBlock(ctx context.Context, bID string) (bool, error) {
	row := q.db.QueryRowContext(ctx, isExistingBlock, bID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
