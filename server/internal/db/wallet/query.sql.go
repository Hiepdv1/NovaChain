// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package dbwallet

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createWallet = `-- name: CreateWallet :one
INSERT INTO wallets (
    address, public_key, public_key_hash, 
    balance, create_at, last_login
) VALUES (
    $1, $2, $3,
    $4, $5, $6
) RETURNING id, address, public_key, public_key_hash, balance, create_at, last_login
`

type CreateWalletParams struct {
	Address       sql.NullString
	PublicKey     sql.NullString
	PublicKeyHash string
	Balance       string
	CreateAt      sql.NullTime
	LastLogin     sql.NullTime
}

func (q *Queries) CreateWallet(ctx context.Context, arg CreateWalletParams) (Wallet, error) {
	row := q.db.QueryRowContext(ctx, createWallet,
		arg.Address,
		arg.PublicKey,
		arg.PublicKeyHash,
		arg.Balance,
		arg.CreateAt,
		arg.LastLogin,
	)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.PublicKey,
		&i.PublicKeyHash,
		&i.Balance,
		&i.CreateAt,
		&i.LastLogin,
	)
	return i, err
}

const createWalletAccessLog = `-- name: CreateWalletAccessLog :exec
INSERT INTO wallet_access_logs (
    wallet_id, access_time, ip,
    user_agent, access_type
) VALUES (
    $1, $2, $3,
    $4, $5
)
`

type CreateWalletAccessLogParams struct {
	WalletID   uuid.NullUUID
	AccessTime sql.NullTime
	Ip         sql.NullString
	UserAgent  sql.NullString
	AccessType sql.NullString
}

func (q *Queries) CreateWalletAccessLog(ctx context.Context, arg CreateWalletAccessLogParams) error {
	_, err := q.db.ExecContext(ctx, createWalletAccessLog,
		arg.WalletID,
		arg.AccessTime,
		arg.Ip,
		arg.UserAgent,
		arg.AccessType,
	)
	return err
}

const decreaseWalletBalance = `-- name: DecreaseWalletBalance :exec
UPDATE wallets
SET balance = balance - $1
WHERE address = $2 AND public_key = $3 AND balance >= $1
`

type DecreaseWalletBalanceParams struct {
	Balance   string
	Address   sql.NullString
	PublicKey sql.NullString
}

func (q *Queries) DecreaseWalletBalance(ctx context.Context, arg DecreaseWalletBalanceParams) error {
	_, err := q.db.ExecContext(ctx, decreaseWalletBalance, arg.Balance, arg.Address, arg.PublicKey)
	return err
}

const existsWalletByAddrAndPubkey = `-- name: ExistsWalletByAddrAndPubkey :one
SELECT EXISTS(SELECT 1 FROM wallets WHERE address = $1 AND public_key = $2)
`

type ExistsWalletByAddrAndPubkeyParams struct {
	Address   sql.NullString
	PublicKey sql.NullString
}

func (q *Queries) ExistsWalletByAddrAndPubkey(ctx context.Context, arg ExistsWalletByAddrAndPubkeyParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, existsWalletByAddrAndPubkey, arg.Address, arg.PublicKey)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getListAccessLogByWalletID = `-- name: GetListAccessLogByWalletID :many
SELECT id, wallet_id, access_time, ip, user_agent, access_type FROM wallet_access_logs WHERE wallet_id = $1 OFFSET $2 LIMIT $3
`

type GetListAccessLogByWalletIDParams struct {
	WalletID uuid.NullUUID
	Offset   int32
	Limit    int32
}

func (q *Queries) GetListAccessLogByWalletID(ctx context.Context, arg GetListAccessLogByWalletIDParams) ([]WalletAccessLog, error) {
	rows, err := q.db.QueryContext(ctx, getListAccessLogByWalletID, arg.WalletID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WalletAccessLog
	for rows.Next() {
		var i WalletAccessLog
		if err := rows.Scan(
			&i.ID,
			&i.WalletID,
			&i.AccessTime,
			&i.Ip,
			&i.UserAgent,
			&i.AccessType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWalletByAddrAndPubkey = `-- name: GetWalletByAddrAndPubkey :one
SELECT id, address, public_key, public_key_hash, balance, create_at, last_login FROM wallets WHERE address = $1 AND public_key = $2 LIMIT 1
`

type GetWalletByAddrAndPubkeyParams struct {
	Address   sql.NullString
	PublicKey sql.NullString
}

func (q *Queries) GetWalletByAddrAndPubkey(ctx context.Context, arg GetWalletByAddrAndPubkeyParams) (Wallet, error) {
	row := q.db.QueryRowContext(ctx, getWalletByAddrAndPubkey, arg.Address, arg.PublicKey)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.PublicKey,
		&i.PublicKeyHash,
		&i.Balance,
		&i.CreateAt,
		&i.LastLogin,
	)
	return i, err
}

const getWalletByAddress = `-- name: GetWalletByAddress :one
SELECT id, address, public_key, public_key_hash, balance, create_at, last_login FROM wallets WHERE address = $1 LIMIT 1
`

func (q *Queries) GetWalletByAddress(ctx context.Context, address sql.NullString) (Wallet, error) {
	row := q.db.QueryRowContext(ctx, getWalletByAddress, address)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.PublicKey,
		&i.PublicKeyHash,
		&i.Balance,
		&i.CreateAt,
		&i.LastLogin,
	)
	return i, err
}

const getWalletByPubKeyHash = `-- name: GetWalletByPubKeyHash :one
SELECT id, address, public_key, public_key_hash, balance, create_at, last_login FROM wallets WHERE public_key_hash = $1 LIMIT 1
`

func (q *Queries) GetWalletByPubKeyHash(ctx context.Context, publicKeyHash string) (Wallet, error) {
	row := q.db.QueryRowContext(ctx, getWalletByPubKeyHash, publicKeyHash)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.PublicKey,
		&i.PublicKeyHash,
		&i.Balance,
		&i.CreateAt,
		&i.LastLogin,
	)
	return i, err
}

const increaseWalletBalance = `-- name: IncreaseWalletBalance :exec
UPDATE wallets
SET balance = balance + $1
WHERE address = $2 AND public_key = $3
`

type IncreaseWalletBalanceParams struct {
	Balance   string
	Address   sql.NullString
	PublicKey sql.NullString
}

func (q *Queries) IncreaseWalletBalance(ctx context.Context, arg IncreaseWalletBalanceParams) error {
	_, err := q.db.ExecContext(ctx, increaseWalletBalance, arg.Balance, arg.Address, arg.PublicKey)
	return err
}

const increaseWalletBalanceByPubKeyHash = `-- name: IncreaseWalletBalanceByPubKeyHash :exec
UPDATE wallets
SET balance = balance + $1
WHERE public_key_hash = $2
`

type IncreaseWalletBalanceByPubKeyHashParams struct {
	Balance       string
	PublicKeyHash string
}

func (q *Queries) IncreaseWalletBalanceByPubKeyHash(ctx context.Context, arg IncreaseWalletBalanceByPubKeyHashParams) error {
	_, err := q.db.ExecContext(ctx, increaseWalletBalanceByPubKeyHash, arg.Balance, arg.PublicKeyHash)
	return err
}

const updateWalletInfoByWalletID = `-- name: UpdateWalletInfoByWalletID :one
UPDATE wallets
SET
    public_key = COALESCE(NULLIF($1::text, ''), public_key),
    public_key_hash = COALESCE(NULLIF($2::text, ''), public_key_hash),
    balance = COALESCE($3, balance),
    address = COALESCE(NULLIF($4::text, ''), address),
    last_login = now()
WHERE id =  $5
RETURNING id, address, public_key, public_key_hash, balance, create_at, last_login
`

type UpdateWalletInfoByWalletIDParams struct {
	PublicKey     sql.NullString
	PublicKeyHash sql.NullString
	Balance       sql.NullString
	Address       sql.NullString
	ID            uuid.UUID
}

func (q *Queries) UpdateWalletInfoByWalletID(ctx context.Context, arg UpdateWalletInfoByWalletIDParams) (Wallet, error) {
	row := q.db.QueryRowContext(ctx, updateWalletInfoByWalletID,
		arg.PublicKey,
		arg.PublicKeyHash,
		arg.Balance,
		arg.Address,
		arg.ID,
	)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.PublicKey,
		&i.PublicKeyHash,
		&i.Balance,
		&i.CreateAt,
		&i.LastLogin,
	)
	return i, err
}

const updateWalletLastLogin = `-- name: UpdateWalletLastLogin :exec
UPDATE wallets
SET last_login = now()
WHERE address = $1 AND public_key = $2
`

type UpdateWalletLastLoginParams struct {
	Address   sql.NullString
	PublicKey sql.NullString
}

func (q *Queries) UpdateWalletLastLogin(ctx context.Context, arg UpdateWalletLastLoginParams) error {
	_, err := q.db.ExecContext(ctx, updateWalletLastLogin, arg.Address, arg.PublicKey)
	return err
}
